#include "wordunit.h"
#include "dfa.h"
#include "synax.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

extern const char* keywords[MAXSIZE]; 
extern const char* words_type[MAXSIZE];
extern const char* op_type[MAXSIZE];
extern const char* sep_type[MAXSIZE];
extern Word words[MAXWORDS];
extern int wordsSize;

const char* synax_ele[] = {"program", "deflist", "tp", "def", "vallist", "fundef",
                              "stmtlist", "args", "param", "stmt", "exp", "initlist", "init",
                              "steplist", "step", "stmt1"};
const int grammar_length[] = {1, 3, 0, 1, 1, 4, 4, 3, 1, 2, 4, 4, 3, 3, 1, 2, 2, 0, 2, 3, 3, 3, 5,
                                  7, 5, 9, 3, 1, 3, 3, 3, 3, 1, 2, 2, 2, 2, 3, 7, 5, 9, 3, 3, 3, 3, 3, 3,
                                  3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 3, 2, 3, 3, 3, 3, 3, 4, 3, 2, 5};
const int grammar_rule[] = {program, deflist, deflist, tp, tp, tp, tp, vallist, vallist, def, def, fundef, fundef,
                          args, args, param, stmtlist, stmtlist, stmt1, stmt1, stmt1, stmt, stmt, stmt, stmt, stmt,
                          initlist, initlist, init, init, init, steplist, steplist, step, step, step, step, step, stmt1, stmt1, stmt1,
                          exp, exp, exp, exp, exp, exp, exp, exp, exp, exp, exp, exp, 
                          exp, exp, exp, exp, exp, exp, exp, exp, exp, exp, exp, exp, exp, stmtlist, stmt};

Sentence* pgm;

Sentence* mkNode(int ruleNum){
    Sentence* newnode = (Sentence*) malloc(sizeof(Sentence));
    newnode->type = SYNAXELE;
    newnode->tval.synVal = grammar_rule[ruleNum];
    int startpos = stkTop - grammar_length[ruleNum] + 1;
    int endpos = stkTop;
    pgm = newnode;
    for(; startpos <= endpos; startpos++)
        newnode->next[startpos] = stcStk[startpos];
    return newnode;
}

Sentence* shift(int nextState, Sentence* stc){
    printf("shift %d\n", nextState);
    stateStk[++stkTop] = nextState;
    stcStk[stkTop] = stc;
    syn_analysis_state = nextState;
    return NULL;
}

Sentence* reduce(int ruleNum){
    printf("reduce %d\n", ruleNum);
    Sentence* newnode = mkNode(ruleNum);
    stkTop = stkTop - grammar_length[ruleNum];
    syn_analysis_state = stateStk[stkTop];
    return newnode;
}

void initSynaxDfa(){
    fin = 0;
    stkTop = 0;
    syn_analysis_state = 0;
}

int getSynFromSentence(Sentence* stc){
    switch(stc->type){
        case ID:
            return ID;
        case KEYWORD:
            return stc->tval.keyIdx;
        case INUM:
            return INUM;
        case FNUM:
            return FNUM;
        case OPERATER:
            return stc->op;
        case SEPERATOR:
            return stc->tval.sepType;
        case SYNAXELE:
            return stc->tval.synVal;
    }
}

Sentence* synaxdfa(Sentence* stc){
    int synid = getSynFromSentence(stc);
    switch(syn_analysis_state){
    }
}

void printWordInfo(Word w){
    printf("(%s):", words_type[w.type - INUM]);
    switch(w.type){
        case ID:
            printf("[%s]\n", w.tval.name);
            break;
        case KEYWORD:
            printf("[%s]\n", keywords[w.tval.keyIdx]);
            break;
        case INUM:
            printf("[%d]\n", w.tval.ivalue);
            break;
        case FNUM:
            printf("[%f]\n", w.tval.fvalue);
            break;
        case OPERATER:
            printf("[%s, %d]\n", op_type[w.tval.opType - UNARY_OP], w.op);
            break;
        case SEPERATOR:
            printf("[%s]\n", sep_type[w.tval.sepType - COMMA]);
            break;
        case SYNAXELE:
            printf("[%s]\n", synax_ele[w.tval.synVal - program]);
            break;
        default:
            printf("\n");
            break;
    }
}

void lex_part(){
    initTrie();
    // char cc[100] = "while Rick hits Morty break dollardollar 10 for 1024 plumbus 1.11  == 2.22 ++ ";
    char cc[100] = "int i, j; int fun(int a, int b){int m;if(a > b) m = a; else m=b;return m;} float a,b;";
    for(int i = 0; i < strlen(cc); i++){
        if(lex(cc[i], 1, i)){
            lex(cc[i], 1, i);
        }
    }
    for(int i = 1; i <= wordsSize; i++){
        printWordInfo(words[i]);
    }
}

void debugsyn(){
    for(int i = 1; i <= stkTop; i++){
        printWordInfo(*(stcStk[i]));
    }
}

void syn_part(){
    initSynaxDfa();
    words[++wordsSize].type = SYNAXELE;
    words[wordsSize].tval.synVal = END;
    for(int i = 1; !fin && i <= wordsSize; i++){
        Sentence* res = synaxdfa(words + i);
        printf("%d state:%d:\n", i, syn_analysis_state);
        debugsyn();
        printf("\n");
        if(res){
            printf("%d:(reduce) state:%d\n", i, syn_analysis_state);
            synaxdfa(res);
            debugsyn();
            printf("\n");
            i--;
        }
    }
}

int main()
{
    printf("lex:\n");
    lex_part();
    printf("\n\nsyntax:\n");
    syn_part();
    printf("%d\n", fin);
    return 0;
}